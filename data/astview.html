<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"/>
  <title>astview - Documentation</title>
  <link rel="stylesheet" type="text/css" href="style.css"/>
</head>

<script LANGUAGE="JavaScript">
  function mailme(name, domain) {location.href='mailto:'+ name + '@'+ domain;}
</script>

<body>
<h1>Astview - Documentation</h1>

<p>Astview is a little desktop program to be used by people that want
to investigate syntax trees, e.g. students and lecturers in compiler
construction courses. Given a parse function <code>p :: String -&gt;
a</code>, where <code>a</code> is a member of haskell's Data
typeclass, astview can show syntax trees in a standard tree
widget.</p>

<p>The program evolved as a case study in a) generic programming and
b) building graphical user interfaces in haskell.</p>

<ul>
<li><a href="#user-guide">User Guide</a></li>
<li><a href="#adding-parsers">Adding Custom Parsers</a></li>
</ul>

<h2>User Guide <a name="user-guide"/> </h2>
<h3>Opening astview</h3>
Astview will be installed in our local cabal directory. Thus you will
find the executable <code>astview</code> in <code>~/.cabal/bin</code>.
<h3>Working with source files</h3>
<p>We tried to make the user interface as common as possible by
following the <a href="http://library.gnome.org/devel/hig-book/stable/">
GNOME human interface guidelines</a> closely. You can open a file by
giving the filename at the CLI:
<pre>astview path/to/mysource.hs</pre>
or simply open it via the file menu. The file's extension will
determine the parser automatically. If there are multiple parsers for
one extension, the first one will be taken. Launching astview without
any files will not enable any parser. Saving works as
expected: Ctrl-S saves, Save-As has to be done via the menu. After changing
a file in astview's text editor, the usual star appears in the title bar, next to the
filename.</p>

<p>Cut-and-Paste functionality works as usual (Ctrl-C/P/X), allowing
to copy-paste source code to or from other programs.</p>

<p>Astview uses the same syntax-higlighting sourceview widget as
GNOME's standard editor gedit, so any language recognized there will
be highlighted by astview. </p>

<h3>Choosing Parsers</h3>
<p>As noted above, the parser is chosen automatically when opening a
file. When editing source code, one can change the parser using the
parser menu issuing an immediate reparse. Ctrl-P reparses the source
at any time.</p>

<h2>Adding Custom Parsers <a name="adding-parsers"/></h2>
<p>The module <code>Language.Astview.Languages</code> contains
a list of all languages (and thus parsers) which are known. You can 
append new languages right here. In this section we show how to add custom parsers
to astview.</p>

<h3>The data type for languages</h3>
First of all we introduce the following data type for parse errors.

<!-- Example EX1 follows: -->
<pre><span class='hs-keyword'>data</span> <span class='hs-conid'>Error</span>
  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Err</span> <span class='hs-comment'>-- ^ no error information</span>
  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ErrMessage</span> <span class='hs-conid'>String</span> <span class='hs-comment'>-- ^ simple error message</span>
  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ErrLocation</span> <span class='hs-conid'>SrcLocation</span> <span class='hs-conid'>String</span> <span class='hs-comment'>-- ^ error message and src loc</span>
</pre>
<!-- Example EX1 done. -->

<p>Since parsers return different amount of error information, we distinguish
between three different types of parsers:

<ul>
  <li>a parser returning no additional informations.</li>
  <li>a parser returning a textual information. </li>
  <li>a parser returning a source location and possibly textual information. </li>
</ul>
</p>

<p>In order to extend astview with your own language you need to know the structure
of the data type <code>Language</code>, which we use to represent languages
and their parsers.</p>


<!-- Example EX2 follows: -->
<pre><span class='hs-keyword'>data</span> <span class='hs-conid'>Language</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>a</span> <span class='hs-varop'>.</span> <span class='hs-conid'>Language</span>
  <span class='hs-layout'>{</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-comment'>-- ^ language name</span>
  <span class='hs-layout'>,</span> <span class='hs-varid'>syntax</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-comment'>-- ^ syntax highlighter name</span>
  <span class='hs-layout'>,</span> <span class='hs-varid'>exts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span> 
   <span class='hs-comment'>-- ^ file extentions which should be associated with this language</span>
  <span class='hs-layout'>,</span> <span class='hs-varid'>parse</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>Error</span> <span class='hs-varid'>a</span> <span class='hs-comment'>-- ^ parse function</span>
  <span class='hs-layout'>,</span> <span class='hs-varid'>toTree</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Tree</span> <span class='hs-conid'>String</span> <span class='hs-comment'>-- ^ how to get a Tree String?</span>
  <span class='hs-layout'>,</span> <span class='hs-varid'>srcLoc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tree</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>SrcLocation</span>
    <span class='hs-comment'>-- ^ selector function for source locations (if supported)</span>
  <span class='hs-layout'>}</span> 
</pre>
<!-- Example EX2 done. -->
<p>
The name is just a string for gui-issues, whereas the second attribute is the name
of the syntax highlighter, which should be associated with that language. As
described above, we use the same syntax highlighting as gedit. </p>

<p>
The parse function maps the input string either to an error value or to an 
abstract syntax tree. Up to now we do not work on the abstract syntax tree, but
on a tree with string-labeled nodes. In module <code>Language.Astview.DataTree</code> you
find the type-generic function <code>data2tree</code> transforming an arbitary value
whose type implements class <code>Data</code> to a tree with string nodes.
After a file's parse we directly apply the given <code>toTree</code>
function throwing away all type informations. Thus we internally represent abstract syntax trees as a tree of strings.
</p>


<p>
The last component of the data type is about source locations. Our implementation of source locations can be found in module <code>Language.Astview.SourceLocation</code>. Since we want to
associate positions in the source text with tree positions, we need to reason about
source locations in the syntax tree. Languages respectively parsers not supporting source 
location use the constant <code>Nothing</code> function here. For the others we map the given
function over the tree of strings in order to get all source locations being represented in the tree. Note that you do not have to reason about the whole tree. The function <code>srcLoc</code> will be automatically applied to all nodes of the tree.
 </p>

<h3>Example: adding your own language</h3>

<p>
In this section we will introduce you to extending astview with our own languages. As
a running example we will use the language <i>Haskell</i> based on the abstract syntax and parser from package <a href="http://hackage.haskell.org/packages/archive/haskell-src-exts/latest/doc/html/Language-Haskell-Exts.html"  target=new>haskell-src-exts</a>. The name and the syntax highlighter are both the string <code>"Haskell"</code>. Although we associate both classical haskell files <code>".hs"</code> and literate haskell files <code>".lhs"</code> with this language. The following code applies the parser to our file content and puts the result in the right context to fit with our resulting data type:
</p>

<!-- Example EX3 follows: -->
<pre><span class='hs-definition'>parHaskell</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>Error</span> <span class='hs-layout'>(</span><span class='hs-conid'>Module</span> <span class='hs-conid'>SrcSpan</span><span class='hs-layout'>)</span>
<span class='hs-definition'>parHaskell</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span>
  <span class='hs-keyword'>case</span> <span class='hs-varid'>parse</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>of</span>
    <span class='hs-conid'>ParseOk</span> <span class='hs-varid'>t</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>t</span>
    <span class='hs-conid'>ParseFailed</span> <span class='hs-layout'>(</span><span class='hs-conid'>SrcLoc</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>l</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>-&gt;</span> 
      <span class='hs-conid'>Left</span> <span class='hs-varop'>$</span> <span class='hs-conid'>ErrLocation</span> <span class='hs-layout'>(</span><span class='hs-conid'>SrcPosition</span> <span class='hs-varid'>l</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-varid'>m</span>
</pre>
<!-- Example EX3 done. -->


<p>If the parse fails, the parser returns information about the incorrect source. We reuse this data to help the user of astview finding the faulty sources. Have a look at module <code>
Language.Astview.SourceLocation</code> to get an impression of our source location types. 
</p>

<p>
The last missing component of our language definition is the extraction of source locations. Currently this is done in an unsafe way, since the algorithm assumes that every constructor named <code>"SrcSpan"</code> is the beginning of a source location and we simply extract the source span information. 
</p>
<!-- Example EX4 follows: -->
<pre><span class='hs-definition'>toSrcLoc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tree</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>SrcLocation</span>
<span class='hs-definition'>toSrcLoc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-str'>"SrcSpan"</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>c1</span><span class='hs-layout'>,</span><span class='hs-varid'>c2</span><span class='hs-layout'>,</span><span class='hs-varid'>c3</span><span class='hs-layout'>,</span><span class='hs-varid'>c4</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> 
  <span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-conid'>SrcSpan</span> <span class='hs-layout'>(</span><span class='hs-varid'>to</span> <span class='hs-varid'>c1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>to</span> <span class='hs-varid'>c2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>to</span> <span class='hs-varid'>c3</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>to</span> <span class='hs-varid'>c4</span><span class='hs-layout'>)</span>
   <span class='hs-keyword'>where</span> 
     <span class='hs-varid'>to</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Tree</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
     <span class='hs-varid'>to</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>read</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rootLabel</span> 
<span class='hs-definition'>toSrcLoc</span> <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> 
</pre>
<!-- Example EX4 done. -->

<p>
Applying the constructor <code>Language</code> to all those functions, we get the value representing the language Haskell in astview:
</p>

<!-- Example EX5 follows: -->
<pre><span class='hs-definition'>haskellexts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Language</span>
<span class='hs-definition'>haskellexts</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Language</span> 
  <span class='hs-str'>"Haskell"</span> 
  <span class='hs-str'>"Haskell"</span> 
  <span class='hs-keyglyph'>[</span><span class='hs-str'>".hs"</span><span class='hs-layout'>,</span><span class='hs-str'>".lhs"</span><span class='hs-keyglyph'>]</span> 
  <span class='hs-varid'>parHaskell</span>
  <span class='hs-layout'>(</span><span class='hs-varid'>data2tree</span><span class='hs-keyglyph'>::</span><span class='hs-conid'>Module</span> <span class='hs-conid'>SrcSpan</span> <span class='hs-keyglyph'>-&gt;</span><span class='hs-conid'>Tree</span> <span class='hs-conid'>String</span><span class='hs-layout'>)</span>
  <span class='hs-varid'>toSrcLoc</span>
</pre>
<!-- Example EX5 done. -->

<p>
In the end one has to append this value to the list <code>knownLanguages</code> in module <code>Language.Astview.Languages</code> to introduce your new language to astview.
</p>

